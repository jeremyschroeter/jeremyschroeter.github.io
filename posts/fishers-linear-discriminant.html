<!DOCTYPE html>
<html>
<head>
    <title>Fisher's Linear Discriminant</title>
    <meta charset="UTF-8">
    <meta content='width=device-width, initial-scale=1' name='viewport'/>
    <link href="https://fonts.googleapis.com/css2?family=Google+Sans+Code:wght@400..700&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="/assets/images/favicon.png" sizes="32x32">
    <link rel="bibliography" href="/assets/references.bib">
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Blog Components -->
    <script defer src="/dist/blog-components.js"></script>
</head>
<body id="post-page">
<div class='content'>
    <blog-nav></blog-nav>
    <blog-header
      title="Fisher's Linear Discriminant"
      subtitle="An algorithm for finding the projection that best separates two classes."
      date="2026-01-07">
    </blog-header>
<div class='wrap article'>
<p>
    Discriminant functions are a family of classification algorithms that directly assign datapoints <blog-math>\boldsymbol{x}_n</blog-math> to a class <blog-math>\mathcal{C}_k</blog-math>.
    The simplest discriminant functions are linear, and divide the input space into regions corresponding to each class.
    The line described by the function is called the <i>decision boundary</i>.
    For example, given the linear discriminant function
    <blog-math block>
        y(\boldsymbol{x}) = \boldsymbol{w}^\top\boldsymbol{x} + w_0
    </blog-math>
    the input vector <blog-math>\boldsymbol{x}</blog-math> is assigned to class <blog-math>\mathcal{C}_1</blog-math> if <blog-math>y(\boldsymbol{x}) \geq 0</blog-math> and to class <blog-math>\mathcal{C}_2</blog-math> otherwise.
</p>

<blog-figure>
    <div id="problem-setup"></div>
    <figcaption>Two classes of data. The decision boundary (solid line) separates the classes; points are classified based on which side they fall on. The dashed line shows the projection direction <blog-math>\boldsymbol{w}</blog-math>.</figcaption>
</blog-figure>

<script>
(function() {
    const width = 300, height = 300;
    const margin = { top: 20, right: 20, bottom: 40, left: 40 };

    // Seeded random for reproducibility
    function mulberry32(a) {
        return function() {
            let t = a += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }
    }
    const seededRandom = mulberry32(42);

    function randn() {
        let u = 0, v = 0;
        while (u === 0) u = seededRandom();
        while (v === 0) v = seededRandom();
        return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    // Generate fixed data
    const n = 40;
    const class1 = [], class2 = [];

    for (let i = 0; i < n; i++) {
        const z1 = randn() * 1.0;
        const z2 = randn() * 0.35;
        const angle1 = 0.95;
        class1.push({
            x: -1.5 + z1 * Math.cos(angle1) - z2 * Math.sin(angle1),
            y: -0.5 + z1 * Math.sin(angle1) + z2 * Math.cos(angle1),
            class: 0
        });
    }

    for (let i = 0; i < n; i++) {
        const z1 = randn() * 1.0;
        const z2 = randn() * 0.35;
        const angle2 = 0.95;
        class2.push({
            x: 1.5 + z1 * Math.cos(angle2) - z2 * Math.sin(angle2),
            y: 0.5 + z1 * Math.sin(angle2) + z2 * Math.cos(angle2),
            class: 1
        });
    }

    const data = [...class1, ...class2];

    // Use a reasonable projection direction for illustration
    const angle = Math.PI / 6;
    const w = [Math.cos(angle), Math.sin(angle)];

    // Create container
    const container = d3.select("#problem-setup");
    container.style("display", "flex")
        .style("flex-direction", "column")
        .style("align-items", "center");

    const svg = container.append("svg")
        .attr("width", width)
        .attr("height", height)
        .style("background", "transparent");

    const xScale = d3.scaleLinear().domain([-4, 4]).range([margin.left, width - margin.right]);
    const yScale = d3.scaleLinear().domain([-4, 4]).range([height - margin.bottom, margin.top]);

    svg.append("g")
        .attr("transform", `translate(0,${height - margin.bottom})`)
        .call(d3.axisBottom(xScale).ticks(5));
    svg.append("g")
        .attr("transform", `translate(${margin.left},0)`)
        .call(d3.axisLeft(yScale).ticks(5));

    svg.append("text")
        .attr("x", width / 2)
        .attr("y", height - 8)
        .attr("text-anchor", "middle")
        .attr("font-size", "12px")
        .text("x₁");
    svg.append("text")
        .attr("x", -height / 2)
        .attr("y", 12)
        .attr("text-anchor", "middle")
        .attr("font-size", "12px")
        .attr("transform", "rotate(-90)")
        .text("x₂");

    // Projection direction (dashed)
    const lineLen = 5;
    svg.append("line")
        .attr("x1", xScale(-lineLen * w[0]))
        .attr("y1", yScale(-lineLen * w[1]))
        .attr("x2", xScale(lineLen * w[0]))
        .attr("y2", yScale(lineLen * w[1]))
        .attr("stroke", "#888")
        .attr("stroke-width", 2)
        .attr("stroke-dasharray", "5,3");

    // Decision boundary (perpendicular to w, solid)
    const perpW = [-w[1], w[0]];
    svg.append("line")
        .attr("x1", xScale(-lineLen * perpW[0]))
        .attr("y1", yScale(-lineLen * perpW[1]))
        .attr("x2", xScale(lineLen * perpW[0]))
        .attr("y2", yScale(lineLen * perpW[1]))
        .attr("stroke", "#333")
        .attr("stroke-width", 2);

    // Data points
    svg.selectAll(".point").data(data)
        .enter().append("circle")
        .attr("cx", d => xScale(d.x))
        .attr("cy", d => yScale(d.y))
        .attr("r", 5)
        .attr("opacity", 0.7)
        .attr("fill", d => d.class === 0 ? "#e63946" : "#457b9d");

    // Label for w
    svg.append("text")
        .attr("x", xScale(2.8 * w[0]) + 10)
        .attr("y", yScale(2.8 * w[1]))
        .attr("font-size", "14px")
        .attr("font-style", "italic")
        .text("w");
})();
</script>

<p>
    How should we choose <blog-math>\boldsymbol{w}</blog-math> to correctly classify as many data points as possible?
    Fisher's Linear Discriminant offers an intuitive solution: choose <blog-math>\boldsymbol{w}</blog-math> such that when the data is projected onto it, the two classes are maximally separated.
</p>

<p>
    A natural starting point is to measure the separation between the projected class means. The class means are given by
    <blog-math block>
        \boldsymbol{m}_1 = \frac{1}{|\mathcal{C}_1|}\sum_{n\in\mathcal{C}_1}\boldsymbol{x}_n \qquad \boldsymbol{m}_2 = \frac{1}{|\mathcal{C}_2|}\sum_{n\in\mathcal{C}_2}\boldsymbol{x}_n
    </blog-math>
    and the projected class means are the scalar quantities <blog-math>m_k = \boldsymbol{w}^\top\boldsymbol{m}_k</blog-math>.
    To maximally separate the projected class means, we maximize
    <blog-math block>
        m_2 - m_1 = \boldsymbol{w}^\top (\boldsymbol{m}_2 - \boldsymbol{m}_1)
    </blog-math>
    This expression, however, is insufficiently constrained: we can make <blog-math>m_2 - m_1</blog-math> arbitrarily large simply by increasing the magnitude of <blog-math>\boldsymbol{w}</blog-math>.
    One remedy is to add the constraint <blog-math>\|\boldsymbol{w}\|^2 = 1</blog-math>, but Fisher's approach handles this more elegantly.
</p>
<p>
    Maximizing the separation of projected means (with the unit norm constraint) yields <blog-math>\boldsymbol{w} \propto \boldsymbol{m}_2 - \boldsymbol{m}_1</blog-math>, which does a reasonable job separating the two groups but may still result in significant class overlap.
</p>

<blog-figure>
    <div id="naive-projection-example"></div>
    <figcaption>Projecting onto the line connecting the class means (<blog-math>\boldsymbol{w} \propto \boldsymbol{m}_2 - \boldsymbol{m}_1</blog-math>) results in significant overlap because it ignores the elongated shape of each class.</figcaption>
</blog-figure>

<script>
(function() {
    const width = 300, height = 300;
    const histWidth = width, histHeight = 120;
    const margin = { top: 20, right: 20, bottom: 40, left: 40 };
    const histMargin = { top: 10, right: 20, bottom: 35, left: 40 };

    // Seeded random for reproducibility (same seed as Fisher example)
    function mulberry32(a) {
        return function() {
            let t = a += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }
    }
    const seededRandom = mulberry32(42);

    function randn() {
        let u = 0, v = 0;
        while (u === 0) u = seededRandom();
        while (v === 0) v = seededRandom();
        return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    // Generate fixed data (same as Fisher example)
    const n = 40;
    const class1 = [], class2 = [];

    for (let i = 0; i < n; i++) {
        const z1 = randn() * 1.0;
        const z2 = randn() * 0.35;
        const angle1 = 0.95;
        class1.push({
            x: -1.5 + z1 * Math.cos(angle1) - z2 * Math.sin(angle1),
            y: -0.5 + z1 * Math.sin(angle1) + z2 * Math.cos(angle1),
            class: 0
        });
    }

    for (let i = 0; i < n; i++) {
        const z1 = randn() * 1.0;
        const z2 = randn() * 0.35;
        const angle2 = 0.95;
        class2.push({
            x: 1.5 + z1 * Math.cos(angle2) - z2 * Math.sin(angle2),
            y: 0.5 + z1 * Math.sin(angle2) + z2 * Math.cos(angle2),
            class: 1
        });
    }

    const data = [...class1, ...class2];

    // Compute naive direction: w ∝ m2 - m1
    const c1 = data.filter(d => d.class === 0);
    const c2 = data.filter(d => d.class === 1);

    const m1 = [d3.mean(c1, d => d.x), d3.mean(c1, d => d.y)];
    const m2 = [d3.mean(c2, d => d.x), d3.mean(c2, d => d.y)];

    const meanDiff = [m2[0] - m1[0], m2[1] - m1[1]];
    const norm = Math.sqrt(meanDiff[0] * meanDiff[0] + meanDiff[1] * meanDiff[1]);
    const w = [meanDiff[0] / norm, meanDiff[1] / norm];

    // Create container
    const container = d3.select("#naive-projection-example");
    container.style("display", "flex")
        .style("flex-direction", "column")
        .style("align-items", "center")
        .style("gap", "0px");

    // Scatter plot
    const svg = container.append("svg")
        .attr("width", width)
        .attr("height", height)
        .style("background", "transparent");

    const xScale = d3.scaleLinear().domain([-4, 4]).range([margin.left, width - margin.right]);
    const yScale = d3.scaleLinear().domain([-4, 4]).range([height - margin.bottom, margin.top]);

    svg.append("g")
        .attr("transform", `translate(0,${height - margin.bottom})`)
        .call(d3.axisBottom(xScale).ticks(5));
    svg.append("g")
        .attr("transform", `translate(${margin.left},0)`)
        .call(d3.axisLeft(yScale).ticks(5));

    svg.append("text")
        .attr("x", width / 2)
        .attr("y", height - 8)
        .attr("text-anchor", "middle")
        .attr("font-size", "12px")
        .text("x₁");
    svg.append("text")
        .attr("x", -height / 2)
        .attr("y", 12)
        .attr("text-anchor", "middle")
        .attr("font-size", "12px")
        .attr("transform", "rotate(-90)")
        .text("x₂");

    // Projection line
    const lineLen = 5;
    svg.append("line")
        .attr("x1", xScale(-lineLen * w[0]))
        .attr("y1", yScale(-lineLen * w[1]))
        .attr("x2", xScale(lineLen * w[0]))
        .attr("y2", yScale(lineLen * w[1]))
        .attr("stroke", "#e76f51")
        .attr("stroke-width", 2)
        .attr("stroke-dasharray", "5,3");

    // Data points
    svg.selectAll(".point").data(data)
        .enter().append("circle")
        .attr("cx", d => xScale(d.x))
        .attr("cy", d => yScale(d.y))
        .attr("r", 5)
        .attr("opacity", 0.7)
        .attr("fill", d => d.class === 0 ? "#e63946" : "#457b9d");

    // Projected points on line
    svg.selectAll(".proj").data(data)
        .enter().append("circle")
        .attr("cx", d => {
            const p = d.x * w[0] + d.y * w[1];
            return xScale(p * w[0]);
        })
        .attr("cy", d => {
            const p = d.x * w[0] + d.y * w[1];
            return yScale(p * w[1]);
        })
        .attr("r", 3)
        .attr("opacity", 0.5)
        .attr("fill", d => d.class === 0 ? "#e63946" : "#457b9d");

    // Histogram
    const histSvg = container.append("svg")
        .attr("width", histWidth)
        .attr("height", histHeight)
        .style("background", "transparent");

    const projections = data.map(d => ({
        proj: d.x * w[0] + d.y * w[1],
        class: d.class
    }));

    const histXScale = d3.scaleLinear().domain([-5, 5]).range([histMargin.left, histWidth - histMargin.right]);

    const bins1 = d3.bin().domain([-5, 5]).thresholds(20)(
        projections.filter(d => d.class === 0).map(d => d.proj)
    );
    const bins2 = d3.bin().domain([-5, 5]).thresholds(20)(
        projections.filter(d => d.class === 1).map(d => d.proj)
    );

    const maxCount = Math.max(d3.max(bins1, d => d.length), d3.max(bins2, d => d.length)) || 1;
    const histYScale = d3.scaleLinear().domain([0, maxCount]).range([histHeight - histMargin.bottom, histMargin.top]);

    histSvg.append("g")
        .attr("transform", `translate(0,${histHeight - histMargin.bottom})`)
        .call(d3.axisBottom(histXScale).ticks(5));
    histSvg.append("g")
        .attr("transform", `translate(${histMargin.left},0)`)
        .call(d3.axisLeft(histYScale).ticks(3));

    histSvg.append("text")
        .attr("x", histWidth / 2)
        .attr("y", histHeight - 5)
        .attr("text-anchor", "middle")
        .attr("font-size", "12px")
        .text("Projection onto w");
    histSvg.append("text")
        .attr("x", -(histHeight - histMargin.bottom + histMargin.top) / 2)
        .attr("y", 12)
        .attr("text-anchor", "middle")
        .attr("font-size", "12px")
        .attr("transform", "rotate(-90)")
        .text("Count");

    // Class 1 bars
    histSvg.selectAll(".bar1").data(bins1)
        .enter().append("rect")
        .attr("x", d => histXScale(d.x0) + 1)
        .attr("y", d => histYScale(d.length))
        .attr("width", d => Math.max(0, histXScale(d.x1) - histXScale(d.x0) - 2))
        .attr("height", d => histYScale(0) - histYScale(d.length))
        .attr("fill", "#e63946")
        .attr("opacity", 0.6);

    // Class 2 bars
    histSvg.selectAll(".bar2").data(bins2)
        .enter().append("rect")
        .attr("x", d => histXScale(d.x0) + 1)
        .attr("y", d => histYScale(d.length))
        .attr("width", d => Math.max(0, histXScale(d.x1) - histXScale(d.x0) - 2))
        .attr("height", d => histYScale(0) - histYScale(d.length))
        .attr("fill", "#457b9d")
        .attr("opacity", 0.6);
})();
</script>

<p>
    Fisher's Linear Discriminant goes further: it finds the weight vector <blog-math>\boldsymbol{w}</blog-math> that maximally separates the projected class means while also minimizing the within-class variance.
</p>
<p>
    The within-class variance of the transformed data from class <blog-math>\mathcal{C}_k</blog-math> is given by
    <blog-math block>
        s_k^2 = \sum_{n\in \mathcal{C}_k}(\boldsymbol{w}^\top\boldsymbol{x}_n - m_k)^2
    </blog-math>
</p>
<p>
    The Fisher criterion captures this trade-off as the ratio of the squared separation of the projected means to the total within-class variance.
    <blog-math block>
        J(\boldsymbol{w}) = \frac{(m_2 - m_1)^2}{s_1^2 + s_2^2}
    </blog-math>
    Because <blog-math>J(\boldsymbol{w})</blog-math> is a ratio, it is invariant to the scale of <blog-math>\boldsymbol{w}</blog-math>, sidestepping the constraint issue mentioned earlier.
    Rewriting this explicitly in terms of <blog-math>\boldsymbol{w}</blog-math> yields
    <blog-math block>
        J(\boldsymbol{w}) = \frac{\boldsymbol{w}^\top \boldsymbol{S}_B\boldsymbol{w}}{\boldsymbol{w}^\top\boldsymbol{S}_W\boldsymbol{w}}
    </blog-math>
    <blog-math block>
        \boldsymbol{S}_B = (\boldsymbol{m}_2 -\boldsymbol{m}_1)(\boldsymbol{m}_2-\boldsymbol{m}_1)^\top
    </blog-math>
    <blog-math block>
        \boldsymbol{S}_W=
\sum_{n\in\mathcal{C}_1}(\boldsymbol{x}_n - \boldsymbol{m}_1)(\boldsymbol{x}_n - \boldsymbol{m}_1)^\top +
\sum_{n\in\mathcal{C}_2}(\boldsymbol{x}_n - \boldsymbol{m}_2)(\boldsymbol{x}_n - \boldsymbol{m}_2)^\top
    </blog-math>
</p>
<p>
    Differentiating with respect to <blog-math>\boldsymbol{w}</blog-math> <blog-appendix-ref key="fisher-derivation"></blog-appendix-ref> and solving, we obtain Fisher's Linear Discriminant:
    <blog-math block>
        \boldsymbol{w} \propto \boldsymbol{S}^{-1}_W(\boldsymbol{m}_2 - \boldsymbol{m}_1)
    </blog-math>
</p>
<p>
    Fisher's Linear Discriminant makes several implicit assumptions.
    It assumes that the classes have similar covariance structures, so that pooling them into a single within-class scatter matrix <blog-math>\boldsymbol{S}_W</blog-math> is reasonable.
    It also assumes that a linear projection can adequately separate the classes.
    When these assumptions hold, particularly for Gaussian-distributed data with equal covariances, Fisher's solution coincides with the Bayes-optimal linear classifier<blog-cite key="bishop2006"></blog-cite>.
</p>

<blog-figure>
    <div id="fisher-viz"></div>
    <figcaption>Drag the handle to change the projection direction. The histogram shows how well-separated the classes are when projected onto <blog-math>\boldsymbol{w}</blog-math>. Click "Show Fisher's solution" to see the optimal direction.</figcaption>
</blog-figure>

<style>
#fisher-viz {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    font-family: inherit;
}
#fisher-viz .viz-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0px;
}
#fisher-viz .scatter-plot, #fisher-viz .histogram {
    background: transparent;
}
#fisher-viz .controls {
    display: flex;
    gap: 15px;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
}
#fisher-viz button {
    padding: 6px 12px;
    border: 1px solid #ccc;
    border-radius: 4px;
    background: white;
    cursor: pointer;
    font-size: 14px;
}
#fisher-viz button:hover {
    background: #f0f0f0;
}
#fisher-viz .stats {
    font-size: 14px;
    color: #666;
}
#fisher-viz .handle {
    cursor: grab;
}
#fisher-viz .handle:active {
    cursor: grabbing;
}
</style>

<script>
(function() {
    const width = 300, height = 300;
    const histWidth = width, histHeight = 120;
    const margin = { top: 20, right: 20, bottom: 40, left: 40 };
    const histMargin = { top: 10, right: 20, bottom: 35, left: 40 };

    // Generate toy data: two 2D Gaussian clusters
    function randn() {
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }

    function generateData() {
        const n = 40;
        const class1 = [], class2 = [];

        // Create anisotropic (elongated) clusters where projecting onto
        // the line connecting means causes overlap, but Fisher's solution works
        // Class 1: elongated along a diagonal
        for (let i = 0; i < n; i++) {
            const z1 = randn() * 1.0;  // long axis
            const z2 = randn() * 0.35; // short axis
            // Rotate by ~55 degrees
            const angle1 = 0.95;
            class1.push({
                x: -1.5 + z1 * Math.cos(angle1) - z2 * Math.sin(angle1),
                y: -0.5 + z1 * Math.sin(angle1) + z2 * Math.cos(angle1),
                class: 0
            });
        }

        // Class 2: elongated along same diagonal
        for (let i = 0; i < n; i++) {
            const z1 = randn() * 1.0;  // long axis
            const z2 = randn() * 0.35; // short axis
            const angle2 = 0.95;
            class2.push({
                x: 1.5 + z1 * Math.cos(angle2) - z2 * Math.sin(angle2),
                y: 0.5 + z1 * Math.sin(angle2) + z2 * Math.cos(angle2),
                class: 1
            });
        }

        return [...class1, ...class2];
    }

    let data = generateData();
    let angle = Math.PI / 4; // Initial angle for w

    // Compute Fisher's optimal direction
    function computeFisherDirection(data) {
        const c1 = data.filter(d => d.class === 0);
        const c2 = data.filter(d => d.class === 1);

        const m1 = [d3.mean(c1, d => d.x), d3.mean(c1, d => d.y)];
        const m2 = [d3.mean(c2, d => d.x), d3.mean(c2, d => d.y)];

        // Compute Sw (within-class scatter)
        let sw = [[0, 0], [0, 0]];
        for (const d of c1) {
            const dx = d.x - m1[0], dy = d.y - m1[1];
            sw[0][0] += dx * dx; sw[0][1] += dx * dy;
            sw[1][0] += dy * dx; sw[1][1] += dy * dy;
        }
        for (const d of c2) {
            const dx = d.x - m2[0], dy = d.y - m2[1];
            sw[0][0] += dx * dx; sw[0][1] += dx * dy;
            sw[1][0] += dy * dx; sw[1][1] += dy * dy;
        }

        // Compute Sw^(-1) * (m2 - m1)
        const det = sw[0][0] * sw[1][1] - sw[0][1] * sw[1][0];
        const swInv = [
            [sw[1][1] / det, -sw[0][1] / det],
            [-sw[1][0] / det, sw[0][0] / det]
        ];

        const meanDiff = [m2[0] - m1[0], m2[1] - m1[1]];
        const w = [
            swInv[0][0] * meanDiff[0] + swInv[0][1] * meanDiff[1],
            swInv[1][0] * meanDiff[0] + swInv[1][1] * meanDiff[1]
        ];

        // Normalize
        const norm = Math.sqrt(w[0] * w[0] + w[1] * w[1]);
        return Math.atan2(w[1] / norm, w[0] / norm);
    }

    function computeFisherCriterion(data, angle) {
        const w = [Math.cos(angle), Math.sin(angle)];
        const c1 = data.filter(d => d.class === 0);
        const c2 = data.filter(d => d.class === 1);

        const proj1 = c1.map(d => d.x * w[0] + d.y * w[1]);
        const proj2 = c2.map(d => d.x * w[0] + d.y * w[1]);

        const m1 = d3.mean(proj1), m2 = d3.mean(proj2);
        const s1 = d3.sum(proj1, p => (p - m1) ** 2);
        const s2 = d3.sum(proj2, p => (p - m2) ** 2);

        return (m2 - m1) ** 2 / (s1 + s2);
    }

    const fisherAngle = computeFisherDirection(data);

    // Create container
    const container = d3.select("#fisher-viz");

    const vizContainer = container.append("div").attr("class", "viz-container");

    const controls = container.append("div").attr("class", "controls");
    controls.append("button").text("Reset data").on("click", () => {
        data = generateData();
        update();
    });
    controls.append("button").text("Show Fisher's solution").on("click", () => {
        angle = computeFisherDirection(data);
        update();
    });
    const statsDiv = controls.append("div").attr("class", "stats");

    // Scatter plot
    const svg = vizContainer.append("svg")
        .attr("class", "scatter-plot")
        .attr("width", width)
        .attr("height", height);

    const xScale = d3.scaleLinear().domain([-4, 4]).range([margin.left, width - margin.right]);
    const yScale = d3.scaleLinear().domain([-4, 4]).range([height - margin.bottom, margin.top]);

    svg.append("g")
        .attr("transform", `translate(0,${height - margin.bottom})`)
        .call(d3.axisBottom(xScale).ticks(5));
    svg.append("g")
        .attr("transform", `translate(${margin.left},0)`)
        .call(d3.axisLeft(yScale).ticks(5));

    // Scatter plot axis labels
    svg.append("text")
        .attr("x", width / 2)
        .attr("y", height - 8)
        .attr("text-anchor", "middle")
        .attr("font-size", "12px")
        .text("x₁");
    svg.append("text")
        .attr("x", -height / 2)
        .attr("y", 12)
        .attr("text-anchor", "middle")
        .attr("font-size", "12px")
        .attr("transform", "rotate(-90)")
        .text("x₂");

    const pointsGroup = svg.append("g");
    const lineGroup = svg.append("g");
    const projGroup = svg.append("g");

    // Histogram
    const histSvg = vizContainer.append("svg")
        .attr("class", "histogram")
        .attr("width", histWidth)
        .attr("height", histHeight);

    const histXScale = d3.scaleLinear().domain([-5, 5]).range([histMargin.left, histWidth - histMargin.right]);
    const histYScale = d3.scaleLinear().domain([0, 15]).range([histHeight - histMargin.bottom, histMargin.top]);

    histSvg.append("g")
        .attr("transform", `translate(0,${histHeight - histMargin.bottom})`)
        .call(d3.axisBottom(histXScale).ticks(5));

    histSvg.append("g")
        .attr("transform", `translate(${histMargin.left},0)`)
        .call(d3.axisLeft(histYScale).ticks(3));

    // Histogram axis labels
    histSvg.append("text")
        .attr("x", histWidth / 2)
        .attr("y", histHeight - 5)
        .attr("text-anchor", "middle")
        .attr("font-size", "12px")
        .text("Projection onto w");
    histSvg.append("text")
        .attr("x", -(histHeight - histMargin.bottom + histMargin.top) / 2)
        .attr("y", 12)
        .attr("text-anchor", "middle")
        .attr("font-size", "12px")
        .attr("transform", "rotate(-90)")
        .text("Count");

    const histBarsGroup = histSvg.append("g");

    function update() {
        const w = [Math.cos(angle), Math.sin(angle)];
        const fisherJ = computeFisherCriterion(data, angle);
        const optimalJ = computeFisherCriterion(data, computeFisherDirection(data));
        statsDiv.html(`J(<b>w</b>) = ${fisherJ.toFixed(3)} &nbsp;|&nbsp; Optimal: ${optimalJ.toFixed(3)}`);

        // Update points
        const points = pointsGroup.selectAll("circle").data(data);
        points.enter().append("circle")
            .attr("r", 5)
            .attr("opacity", 0.7)
            .merge(points)
            .attr("cx", d => xScale(d.x))
            .attr("cy", d => yScale(d.y))
            .attr("fill", d => d.class === 0 ? "#e63946" : "#457b9d");
        points.exit().remove();

        // Update projection line
        const lineLen = 5;
        const lineData = [
            { x: -lineLen * w[0], y: -lineLen * w[1] },
            { x: lineLen * w[0], y: lineLen * w[1] }
        ];

        lineGroup.selectAll("*").remove();
        lineGroup.append("line")
            .attr("x1", xScale(lineData[0].x))
            .attr("y1", yScale(lineData[0].y))
            .attr("x2", xScale(lineData[1].x))
            .attr("y2", yScale(lineData[1].y))
            .attr("stroke", "#2a9d8f")
            .attr("stroke-width", 2)
            .attr("stroke-dasharray", "5,3");

        // Draggable handle
        lineGroup.append("circle")
            .attr("class", "handle")
            .attr("cx", xScale(2.5 * w[0]))
            .attr("cy", yScale(2.5 * w[1]))
            .attr("r", 10)
            .attr("fill", "#2a9d8f")
            .attr("stroke", "white")
            .attr("stroke-width", 2)
            .call(d3.drag()
                .on("drag", function(event) {
                    const mx = xScale.invert(event.x);
                    const my = yScale.invert(event.y);
                    angle = Math.atan2(my, mx);
                    update();
                }));

        // Project points onto line
        const projections = data.map(d => ({
            proj: d.x * w[0] + d.y * w[1],
            class: d.class
        }));

        // Show projected points on the line
        projGroup.selectAll("*").remove();
        projGroup.selectAll("circle").data(data)
            .enter().append("circle")
            .attr("r", 3)
            .attr("opacity", 0.5)
            .attr("cx", d => {
                const p = d.x * w[0] + d.y * w[1];
                return xScale(p * w[0]);
            })
            .attr("cy", d => {
                const p = d.x * w[0] + d.y * w[1];
                return yScale(p * w[1]);
            })
            .attr("fill", d => d.class === 0 ? "#e63946" : "#457b9d");

        // Update histogram
        const bins1 = d3.bin().domain([-5, 5]).thresholds(20)(
            projections.filter(d => d.class === 0).map(d => d.proj)
        );
        const bins2 = d3.bin().domain([-5, 5]).thresholds(20)(
            projections.filter(d => d.class === 1).map(d => d.proj)
        );

        histBarsGroup.selectAll("*").remove();

        // Class 1 bars
        histBarsGroup.selectAll(".bar1").data(bins1)
            .enter().append("rect")
            .attr("class", "bar1")
            .attr("x", d => histXScale(d.x0) + 1)
            .attr("y", d => histYScale(d.length))
            .attr("width", d => Math.max(0, histXScale(d.x1) - histXScale(d.x0) - 2))
            .attr("height", d => histYScale(0) - histYScale(d.length))
            .attr("fill", "#e63946")
            .attr("opacity", 0.6);

        // Class 2 bars
        histBarsGroup.selectAll(".bar2").data(bins2)
            .enter().append("rect")
            .attr("class", "bar2")
            .attr("x", d => histXScale(d.x0) + 1)
            .attr("y", d => histYScale(d.length))
            .attr("width", d => Math.max(0, histXScale(d.x1) - histXScale(d.x0) - 2))
            .attr("height", d => histYScale(0) - histYScale(d.length))
            .attr("fill", "#457b9d")
            .attr("opacity", 0.6);

    }

    update();
})();
</script>

<blog-appendix>

<blog-appendix-item key="fisher-derivation" title="Derivation of Fisher's Solution">
<p>To maximize the Fisher criterion</p>

<blog-math block>
    J(\boldsymbol{w}) = \frac{\boldsymbol{w}^\top \boldsymbol{S}_B\boldsymbol{w}}{\boldsymbol{w}^\top\boldsymbol{S}_W\boldsymbol{w}}
</blog-math>

<p>we differentiate with respect to <blog-math>\boldsymbol{w}</blog-math> and set the result to zero. Using the quotient rule:</p>

<blog-math block>
    \frac{\partial J}{\partial \boldsymbol{w}} = \frac{2\boldsymbol{S}_B\boldsymbol{w}(\boldsymbol{w}^\top\boldsymbol{S}_W\boldsymbol{w}) - 2\boldsymbol{S}_W\boldsymbol{w}(\boldsymbol{w}^\top\boldsymbol{S}_B\boldsymbol{w})}{(\boldsymbol{w}^\top\boldsymbol{S}_W\boldsymbol{w})^2} = 0
</blog-math>

<p>The numerator must equal zero, so:</p>

<blog-math block>
    \boldsymbol{S}_B\boldsymbol{w}(\boldsymbol{w}^\top\boldsymbol{S}_W\boldsymbol{w}) = \boldsymbol{S}_W\boldsymbol{w}(\boldsymbol{w}^\top\boldsymbol{S}_B\boldsymbol{w})
</blog-math>

<p>Since <blog-math>\boldsymbol{w}^\top\boldsymbol{S}_B\boldsymbol{w}</blog-math> and <blog-math>\boldsymbol{w}^\top\boldsymbol{S}_W\boldsymbol{w}</blog-math> are scalars, we can divide both sides by these quantities and rearrange:</p>

<blog-math block>
    \frac{\boldsymbol{S}_B\boldsymbol{w}}{\boldsymbol{w}^\top\boldsymbol{S}_B\boldsymbol{w}} = \frac{\boldsymbol{S}_W\boldsymbol{w}}{\boldsymbol{w}^\top\boldsymbol{S}_W\boldsymbol{w}}
</blog-math>

<p>This implies <blog-math>\boldsymbol{S}_B\boldsymbol{w}</blog-math> and <blog-math>\boldsymbol{S}_W\boldsymbol{w}</blog-math> point in the same direction, so we can write the generalized eigenvalue problem:</p>

<blog-math block>
    \boldsymbol{S}_B\boldsymbol{w} = \lambda\boldsymbol{S}_W\boldsymbol{w}
</blog-math>

<p>where <blog-math>\lambda = \frac{\boldsymbol{w}^\top\boldsymbol{S}_B\boldsymbol{w}}{\boldsymbol{w}^\top\boldsymbol{S}_W\boldsymbol{w}} = J(\boldsymbol{w})</blog-math>. Rearranging:</p>

<blog-math block>
    \boldsymbol{S}_W^{-1}\boldsymbol{S}_B\boldsymbol{w} = \lambda\boldsymbol{w}
</blog-math>

<p>Now, since <blog-math>\boldsymbol{S}_B = (\boldsymbol{m}_2 - \boldsymbol{m}_1)(\boldsymbol{m}_2 - \boldsymbol{m}_1)^\top</blog-math> is a rank-1 matrix, <blog-math>\boldsymbol{S}_B\boldsymbol{w}</blog-math> is always in the direction of <blog-math>(\boldsymbol{m}_2 - \boldsymbol{m}_1)</blog-math>:</p>

<blog-math block>
    \boldsymbol{S}_B\boldsymbol{w} = (\boldsymbol{m}_2 - \boldsymbol{m}_1)\underbrace{(\boldsymbol{m}_2 - \boldsymbol{m}_1)^\top\boldsymbol{w}}_{\text{scalar}}
</blog-math>

<p>Substituting back:</p>

<blog-math block>
    \lambda\boldsymbol{S}_W\boldsymbol{w} \propto (\boldsymbol{m}_2 - \boldsymbol{m}_1)
</blog-math>

<p>Since we only care about the direction of <blog-math>\boldsymbol{w}</blog-math> (not its magnitude), we can drop the scalar factors to obtain:</p>

<blog-math block>
    \boldsymbol{w} \propto \boldsymbol{S}_W^{-1}(\boldsymbol{m}_2 - \boldsymbol{m}_1)
</blog-math>
</blog-appendix-item>

<blog-appendix-item key="implementation" title="Fisher's Linear Discriminant Implementation">
<blog-code python>
    def fisher_ld(X, y):
    classes = np.unique(y)
    n_features = X.shape[1]

    Sw = np.zeros((n_features, n_features))
    means = {}

    for k in classes:
        vals = X[y==k]
        means[k] = vals.mean(axis=0)
        centered = vals - means[k]
        Sw += centered.T @ centered

    mean_diff = means[classes[1]] - means[classes[0]]
    w = np.linalg.solve(Sw, mean_diff)
    return w
</blog-code>
</blog-appendix-item>

</blog-appendix>

</div>
</div>
</body>
</html>
